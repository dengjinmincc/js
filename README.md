# JavaScript深度学习
* JavaScript作用域学习笔记
* JavaScript原型学习笔记
* JavaScript闭包学习笔记
* JavaScript构造函数学习笔记
* JavaScript面向对象编程学习笔记
* JavaScript设计模式学习笔记
***
## JavaScript作用域学习笔记

作用域是JavaScript中最重要的概念之一，要想学好JavaScript就必须掌握作用域这个概念。
	
### 作用域

1. 什么是作用域

	几乎所有编程语言最基本的能力之一是存储变量的值并可以访问和修改，那么就需要一套设计良好的规则来存储变量并可以方便的找到该变量，这套规则被称为作用域。简单来说，作用域就是变量和函数可访问的范围。
		
2. 全局作用域

	在任何地方都能访问到的变量拥有全局作用域。
		
	(1) 定义在最外层函数外面的变量和最外层函数拥有全局作用域。
		
	 	var outer = "hello world"; 
	 		
	 	function foo(){
	 		var inner = "hello js!";
				
			function bar(){
				console.log(inner); 
			}				
 		}
	 		
	 	console.log(outer); // "hello world"
	 	console.log(inner); //发生错误，无法访问到inner
	 	console.log(foo()); //"hello js!"
	 	console.log(bar()); //发生错误，无法访问到bar()
	 	
	 (2)在非严格模式下未声明直接初始化的变量。
	 
	 es5中引入了严格模式，即之前许多不确定的行为在严格模式下会抛出错误。例如在严格模式下使用未声明直接初始化的变量会抛出ReferenceError错误。
	 	
	 (3)所有window对象下的属性都拥有全局作用域。
3. 函数作用域

	函数作用域即变量或函数定义在外层函数中，只能在外层函数中进行访问，在其之外的地方访问会抛出错误。
		
		
		function foo(){
			var msg = "hello world"; 
				
			function bar(){
				console.log(msg); 
			}
		}
			
		console.log(msg); //发生错误
		console.log(bar()); //发生错误
		
		
4. 块作用域

	es6中新增了let命令，用于申明变量，与var用法类似，只不过所声明的变量只在let命令所在的代码块有效，即声明的变量拥有块级作用域。
		
		
		{
			let a = 5; 
			var b = 10; 
		}
			
		a //ReferenceError: a is not defined
		b //10		
		
		
	这证明由let声明的变量具有块级作用域
	
	除了let以外，es6还新增了const命令，同样可以用来创建具有块级作用域的变量，但其值是固定的，一旦修改将引发错误。
	
		var foo = true; 
		
		if(foo){
			var a = 2; 
			const b = 3; 
			
			a = 3; //正常
			b = 4; //错误
		}	
		
		console.log(a); //3
		console.log(b); //ReferenceError
		
	虽然在es6之前的版本中不存在块级作用域这个概念，但可以使用匿名函数模拟块级作用域。（匿名函数：没有名字的函数，有时也称为纳姆达函数），其语法形式如下：
		
		
		(function(){
			
			//块级作用域
				
		})()
	
		
	以上代码的意思是创建并立即调用一个匿名函数，第一个圆括号中是函数表达式，第二个圆括号表示立刻执行。
		
### 作用域链

当代码在环境中执行时，会创建当前对象的作用域链来保证对执行环境中有权访问的变量和函数的有序访问。作用域链的第一个对象始终是当前正在执行的代码所在环境的变量对象。

如果执行环境是函数，那么将其活动对象作为作用域链中的第一个对象，其包含对象作为第二个对象，以此类推。

当在执行环境中查找标识符时，会沿着作用域链一级一级进行搜索，当找到第一个同名标识符时，会停止搜索；若没有找到，会沿着作用域链一直搜索，直到全局作用域。若还是没有找到，便报错。

***
## JavaScript闭包学习笔记

1. 什么是闭包

	当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
	
		function foo(){
			var a = 2; 
		
			function bar(){
				console.log(a); 
			}
			
			return bar; 
		}
	
		var baz = foo(); 
		baz(); //2--这就是闭包的效果
	
	在这个例子中，函数bar()的词法作用于能够访问foo()的内部作用域。foo()函数调用后返回bar()函数并赋给baz，然后调用。其实质是通过不同的标识符调用bar()函数。由于bar()函数定义在foo()内部，使得bar()拥有涵盖foo()内部的作用域。因此，即使bar()在所在词法作用域之外执行，也不会发生错误。
	
	那么当foo()执行完毕后，foo()的整个内部作用域是否会被销毁呢?我们知道，在一般情况下，由于js的自动垃圾收集机制，当函数执行完毕后，其中的局部作用域将会被销毁，以此来释放内存供将来使用。但在这个例子中，由于bar()拥有涵盖foo()内部作用域的闭包，使得其内部作用域不会被销毁，以供bar()使用。
	
	bar()拥有对内部作用域的引用，而这个引用就叫做闭包。
	
	而司徒正美也从另一个角度解释了闭包：
	
	> 简单来说，闭包就是在另一个作用域中保存了一份它从上一级函数或> 作用域取得的变量（键值对），而这些键值对是不会随上一级函数的> 执行完成而销毁。周爱民说得更清楚，闭包就是“属性表”，闭包就是> 一个数据块，闭包就是一个存放着“Name=Value”的对照表。就这简单。但是，必须要强调，闭包是一个运行期概念。
	
2. 	循环和闭包
	
	说到循环，for循环是最常见的例子。
	
		for(var i = 0; i < 5; i++){
			setTimeout(function timer(){
				console.log(i);
			}, i * 1000);
		}
	
	在这个例子中，我们可能会理所当然的认为它的运行结果是每隔一秒输出0到4。而现实是，它会每隔一秒输出5。那么是什么原因导致这段代码的运行结果同其暗示的语义不一致呢？
	
	其原因就在于在每一次timer()运行的时候，我们都会假设其会捕获一个副本“i”。但尽管五个函数是在每一次迭代中分别定义的，但它们都被封闭在一个作用域中，由作用域的工作原理可知，他们会共享同一个"i"。
	
	但从另一个角度来看，延迟函数的回调本来就会在for循环之后执行，即使在每次迭代中，setTimeout(..., 0)，那么会输出5也是毋庸置疑的。但是有没有什么办法让我们输出我们想要的结果呢？答案当然是有！
	
	在上一个例子中，我们知道没有得出理想结果的原因是它们并没有捕获各自的副本（共享同一个“i”）。那我们让它们都拥有各自的副本不就好了？可以通过立即创建函数并执行（即IIFE）这种方式来为他们各自创建块级作用域，以达到目的，例如这样的：
	
		for(var i = 0; i < 5; i++){
			(function(){
				setTimeout(function timer(){
					console.log(i);
				}, i * 1000);
			})();
		}
		
	这种方式可以达到目的吗？其实这样是不行的。通过IIFE这种方式，我们在每次迭代中都为其创建了一个封闭的作用域，但在这个封闭的作用域中什么都没有，它们实质上还是在共享同一个循环变量。我们需要为这个封闭的作用域添加一些东西才能达到想要的效果：
	
		for(var i = 0; i < 5; i++){
			(function(){
				var j = i; 
				setTimeout(function timer(){
					console.log(j); 
				}, j * 1000);
			})();
		}
		
	这下就大功告成了！也可以这样写：
	
		for(var i = 0; i < 5; i++){
			(function(j){
				setTimeout(function timer(){
					console.log(i); 
				}, i * 1000);
			})(i);
		}
		
	不知道大家有没有发现，我们幸幸苦苦做的，其实就是在创建一个块级作用域而已！之前js中没有块级作用域这个概念，但es6中新增了let命令啊，由它所声明的变量只在所在代码块中有效。这不一直就是我们想要的吗？由此，我们可以把上面可达到目的代码改写一下：
	
		for(var i = 0; i < 5; i++){
			let j = i; 
			setTimeout(function timer(){
				console.log(j);
			}, j * 1000);
		}
		
	其实这样写更方便：
	
		for(let i = 0; i < 5; i++){
			setTimeout(function timer(){
				console.log(i); 
			}, i * 1000); 
		}
		
	